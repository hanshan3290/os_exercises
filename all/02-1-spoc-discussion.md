#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别：
 
UEFI比BIOS少了两层引导记录，它在所有平台上提供一致的启动服务。除此之外，UEFI具有可信启动流程，通过签名进行认证，使得其安全性高于BIOS。

 2. 描述PXE的大致启动流程：
 
首先开机并做自我测试，然后与服务器建立连接，下载内核镜像，然后客户端就可以根据下载的文件启动机器。


## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 
运行自检程序后装入主引导记录，然后活动分区的引导扇区被装入内存，NTLDR从引导扇区被装入并初始化，将处理器的实模式改为32位平滑内存模式。NTLDR开始运行适当的小文件系统驱动程序，读boot.ini文件后装载所选操作系统，运行Ntdetect。Ntdetect搜索硬件。然后NTLDR装载Ntoskrnl.exe，Hal.dll和系统信息集合并把控制权交给Ntoskrnl.exe，这时,启动程序结束,装载阶段开始。

 2. 了解GRUB的启动流程。
 
计算机启动后装入MBR，GRUB的步骤1包含在MBR中。由于受MBR的大小限制，步骤一所做的装载GRUB的下一步骤。步骤1既可以直接装载步骤2，也可以装载步骤1.5：GRUB的步骤1.5包含在MBR后面的30千字节中。步骤1.5载入步骤2。当步骤2启动后，它将呈现一个界面来让用户选择启动的操作系统。一旦选择了启动选项，GRUB把选择的内核载入内存并把控制交给内核。

 3. 比较NTLDR和GRUB的功能有差异。


 4. 了解u-boot的功能。

Das U-Boot 是一个主要用于嵌入式系统的开机加载程式，可以支援多种不同的计算机系统结构，包括PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常。
 
中断：键盘输入，鼠标输入，硬件的接入，磁盘的读写。
异常：除法计算的除零错，访问无权限的存储空间。

 2. Linux的系统调用有哪些？大致的功能分类有哪些？    
 
Linux系统调用的数目约为200个，大致分类为：进程控制，文件系统控制，系统控制，内存管理，网络管理，socket管理，用户管理，进程间通信等。

 3. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？ 
 
ucore的系统调用共22个，为exit,fork,wait,exec,yield,kill,getpid,putc,pgdir,gettime,lab6_set_priority,sleep,open,close,read,write,seek,fstat,fsync,getcwd,getdirentry,dup。大致可分为进程管理，内存管理，文件操作等类别。

 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)

objdump: 反汇编目标文件或者可执行文件。
nm：显示关于对象文件、可执行文件以及对象文件库里的符号信息。
file：检测文件类型。

系统调用本质是向应用程序提供一些基本的函数的接口。这些函数都位于操作系统的内核。
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)

当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
系统调用执行的过程：应用程序调用C库函数，然后通过软中断进入内核，系统会根据系统调用号选取不同的实现方法，运行并返回结果。

## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行代码，分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。并说明`int`、`iret`、`call`和`ret`的指令准确功能

代码编写时候，函数调用使用call等调用库函数，系统调用使用int等调用系统函数。
执行时候，系统调用需要调用系统的内核服务，而函数调用不用进入内核。
int的功能是进入系统调用，iret的功能是系统调用结束后返回。call的功能是调用函数，ret的功能是函数调用完以后返回。
